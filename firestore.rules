rules_version = '2';

// =============================================================================
// FIRESTORE TTL POLICIES REQUIRED
// =============================================================================
// Configure these TTL policies in Firebase Console or via gcloud CLI:
//
// 1. message_nonces collection:
//    Field: expireAt | Deletes documents ~1 hour after message creation
//
// 2. message_tokens collection:
//    Field: expireAt | Deletes documents ~1 hour after token creation
//
// 3. message_sequences collection:
//    Field: expireAt | Deletes documents 30 days after last update
//
// 4. message_rate_limits collection:
//    Field: expireAt | Deletes documents 2 hours after last attempt
//
// To create TTL policies via gcloud:
//   gcloud firestore fields ttls update expireAt \
//     --collection-group=message_nonces \
//     --enable-ttl
//
// Repeat for: message_tokens, message_sequences, message_rate_limits
// =============================================================================

service cloud.firestore {
  match /databases/{database}/documents {

    // Helper function: Check if user is authenticated
    function isAuthenticated() {
      return request.auth != null;
    }

    // Helper function: Check if user owns the document
    function isOwner(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }

    // Users collection
    match /users/{userId} {
      // Users can read their own document
      // Partners can also read each other's documents (for name, avatar, publicKey)
      // Uses partnerIdHash for security - partnerId itself is encrypted
      allow read: if isOwner(userId)
        || (isAuthenticated() && resource.data.partnerIdHash == hashing.sha256(request.auth.uid.toUtf8()));

      // Users can create their own document during signup
      allow create: if isOwner(userId)
        && request.resource.data.keys().hasAll(['email', 'publicKey', 'createdAt'])
        && request.resource.data.publicKey is string
        && request.resource.data.publicKey.size() > 0;

      // Users can update their own document
      allow update: if isOwner(userId)
        // Never allow changing email after creation
        && (!request.resource.data.diff(resource.data).affectedKeys().hasAny(['email']))
        // Allow updating specific fields only
        && request.resource.data.diff(resource.data).affectedKeys()
           .hasOnly(['name', 'avatar', 'lastActive', 'preferences',
                     'twoFactorEnabled', 'backupCodes', 'twoFactorEnabledAt',
                     'twoFactorDisabledAt', 'backupCodesRegeneratedAt', 'linkedDevices',
                     'publicKey', 'publicKeyVersion', 'publicKeyRotatedAt', 'publicKeyFingerprint',
                     'partnerId', 'partnerIdHash', 'partnerPublicKey', 'partnerKeyVersion', 'partnerLinkedAt']);

      // Users can delete their own account
      allow delete: if isOwner(userId);

      // Key history subcollection - stores archived public keys
      match /keyHistory/{version} {
        // Only owner and their partner can read key history
        allow read: if isOwner(userId)
          || (isAuthenticated() && get(/databases/$(database)/documents/users/$(userId)).data.partnerId == request.auth.uid);

        // Only the owner can create key history entries (during key rotation)
        allow create: if isOwner(userId)
          && request.resource.data.keys().hasAll(['publicKey', 'version', 'fingerprint', 'archivedAt'])
          && request.resource.data.publicKey is string
          && request.resource.data.version is int
          && request.resource.data.fingerprint is string
          && request.resource.data.archivedAt is string;

        // Key history is immutable - no updates or deletes
        allow update, delete: if false;
      }

      // Seen nonces subcollection - Client-side replay protection cache
      match /seen_nonces/{nonceId} {
        // Users can only read/write their own seen nonces
        allow read, create: if isOwner(userId);

        // Nonces are immutable once created
        allow update, delete: if false;
      }

      // Message sequences subcollection - Client-side sequence tracking
      match /message_sequences/{conversationId} {
        // Users can only read/write their own message sequences
        allow read, write: if isOwner(userId);
      }
    }

    // Security log collection - Write only, no reads (audit trail)
    match /securityLog/{logId} {
      // Users can create security logs for their own actions
      allow create: if isAuthenticated()
        && request.resource.data.userId == request.auth.uid
        && request.resource.data.keys().hasAll(['userId', 'event', 'timestamp'])
        && request.resource.data.event is string
        && request.resource.data.timestamp == request.time;

      // No reads - logs are for admin/security review only
      allow read: if false;

      // No updates or deletes - logs are immutable
      allow update, delete: if false;
    }

    // Support tickets collection
    match /supportTickets/{ticketId} {
      // Users can create support tickets
      allow create: if isAuthenticated()
        && request.resource.data.userId == request.auth.uid
        && request.resource.data.keys().hasAll(['userId', 'name', 'email', 'type', 'description', 'status', 'createdAt'])
        && request.resource.data.status == 'pending'
        && request.resource.data.createdAt == request.time;

      // Users can read their own tickets
      allow read: if isAuthenticated()
        && resource.data.userId == request.auth.uid;

      // No updates or deletes by users - only admins can update ticket status
      allow update, delete: if false;
    }

    // Message nonces collection - Server-side replay protection
    // Only Cloud Functions can write via Admin SDK
    match /message_nonces/{nonceId} {
      allow read, write: if false;
    }

    // Message sequences collection - Server-side sequence tracking
    // Only Cloud Functions can write via Admin SDK
    match /message_sequences/{sequenceId} {
      allow read, write: if false;
    }

    // Message tokens collection - One-time validation tokens
    // Only Cloud Functions can write via Admin SDK
    match /message_tokens/{tokenId} {
      allow read, write: if false;
    }

    // Message rate limits collection - Server-side rate limiting
    // Only Cloud Functions can write via Admin SDK
    match /message_rate_limits/{limitId} {
      allow read, write: if false;
    }

    // Conversations collection
    match /conversations/{conversationId} {
      function isConversationParticipant() {
        return isAuthenticated() &&
          request.auth.uid in resource.data.participants;
      }

      function isConversationParticipantForCreate() {
        return isAuthenticated() &&
          request.auth.uid in get(/databases/$(database)/documents/conversations/$(conversationId)).data.participants;
      }

      allow read: if isConversationParticipant();

      allow create: if isAuthenticated()
        && request.auth.uid in request.resource.data.participants
        && request.resource.data.participants.size() == 2
        && request.resource.data.keys().hasAll(['participants', 'createdAt', 'lastMessageAt'])
        && request.resource.data.createdAt is timestamp
        && request.resource.data.lastMessageAt is timestamp;

      allow update: if isConversationParticipant()
        && request.resource.data.diff(resource.data).affectedKeys()
           .hasOnly(['lastMessage', 'lastMessageAt', 'unreadCount', 'typing']);

      allow delete: if false;

      // Messages subcollection
      match /messages/{messageId} {
        function isMessageParticipant() {
          return isAuthenticated() &&
            (request.auth.uid == resource.data.senderId ||
             request.auth.uid == resource.data.recipientId);
        }

        function isValidToken(tokenId) {
          let token = get(/databases/$(database)/documents/message_tokens/$(tokenId));
          return token != null
            && token.data.messageId == messageId
            && token.data.senderId == request.auth.uid
            && token.data.expiresAt > request.time;
        }

        allow read: if isConversationParticipantForCreate();

        allow create: if isConversationParticipantForCreate()
          && request.resource.data.senderId == request.auth.uid
          && request.resource.data.keys().hasAll(['content', 'senderId', 'recipientId', 'timestamp', 'senderKeyVersion', 'recipientKeyVersion', 'validationToken'])
          && request.resource.data.content is string
          && request.resource.data.content.size() > 0
          && request.resource.data.content.size() < 100000
          && request.resource.data.senderKeyVersion is int
          && request.resource.data.recipientKeyVersion is int
          && request.resource.data.timestamp is timestamp
          && request.resource.data.validationToken is string
          && request.resource.data.validationToken.size() > 0
          && isValidToken(request.resource.data.validationToken);

        allow update: if isAuthenticated()
          && (
            (request.auth.uid == resource.data.recipientId
              && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['status', 'readAt', 'deliveredAt']))
            ||
            (request.auth.uid == resource.data.senderId
              && resource.data.isDeleted != true
              && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['content', 'isEdited', 'editedAt'])
              && request.resource.data.isEdited == true
              && request.resource.data.editedAt is timestamp
              && request.resource.data.content is string
              && request.resource.data.content.size() > 0
              && request.resource.data.content.size() < 100000)
            ||
            (request.auth.uid == resource.data.senderId
              && resource.data.isDeleted != true
              && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['isDeleted', 'deletedAt', 'content'])
              && request.resource.data.isDeleted == true
              && request.resource.data.deletedAt is timestamp)
          );

        allow delete: if false;
      }
    }

    // Partner invites collection (for connecting partners)
    match /partnerInvites/{inviteCode} {
      // Helper function: Check if invite code format is valid (8 alphanumeric chars)
      function isValidInviteCode() {
        return inviteCode.size() == 8;
      }

      // Helper function: Check if invite has not expired
      function isNotExpired() {
        return resource.data.expiresAt > request.time;
      }

      // Helper function: Validate public key format (base64 encoded, reasonable length)
      function isValidPublicKey(key) {
        return key is string && key.size() > 50 && key.size() < 1000;
      }

      // Anyone authenticated can read (needed to accept invites and query own invites)
      allow read: if isAuthenticated();

      // Users can create invites for themselves with strict validation
      allow create: if isAuthenticated()
        && isValidInviteCode()
        && request.resource.data.userId == request.auth.uid
        && request.resource.data.keys().hasAll([
            'userId', 'userName', 'publicKey', 'publicKeyVersion',
            'publicKeyFingerprint', 'signature', 'createdAt', 'expiresAt', 'used'
           ])
        && request.resource.data.used == false
        // Validate public key is present and reasonably formatted
        && isValidPublicKey(request.resource.data.publicKey)
        // Validate key version is a positive integer
        && request.resource.data.publicKeyVersion is int
        && request.resource.data.publicKeyVersion > 0
        // Validate fingerprint is present (32 hex chars with spaces = ~39 chars)
        && request.resource.data.publicKeyFingerprint is string
        && request.resource.data.publicKeyFingerprint.size() >= 32
        // Validate signature is present (SHA-256 = 64 hex chars)
        && request.resource.data.signature is string
        && request.resource.data.signature.size() == 64
        // Validate timestamps
        && request.resource.data.createdAt is timestamp
        && request.resource.data.expiresAt is timestamp
        // Ensure expiry is in the future but not too far (max 48 hours)
        && request.resource.data.expiresAt > request.time
        && request.resource.data.expiresAt < request.time + duration.value(48, 'h')
        // Validate username is reasonable
        && request.resource.data.userName is string
        && request.resource.data.userName.size() > 0
        && request.resource.data.userName.size() <= 100;

      // Users can mark an invite as used (when accepting)
      // Additional validation to prevent abuse
      allow update: if isAuthenticated()
        && resource.data.used == false
        && request.resource.data.used == true
        && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['used', 'usedAt', 'usedBy'])
        // Cannot accept own invite
        && resource.data.userId != request.auth.uid
        // Validate usedBy is the current user
        && request.resource.data.usedBy == request.auth.uid
        // Ensure invite hasn't expired
        && isNotExpired();

      // Only the creator can delete their unused invite
      allow delete: if isAuthenticated()
        && resource.data.userId == request.auth.uid
        && resource.data.used == false;
    }

    // Device linking collection (temporary, short-lived documents)
    match /deviceLinking/{linkToken} {
      // Helper function: Check if link token is valid format (32-64 chars, URL-safe base64)
      function isValidLinkToken() {
        return linkToken.size() >= 32 && linkToken.size() <= 64;
      }

      // Helper function: Check if device linking session hasn't expired
      function isLinkNotExpired() {
        return resource.data.expiresAt > request.time;
      }

      // Only the owner can create device linking sessions
      allow create: if isAuthenticated()
        && isValidLinkToken()
        && request.resource.data.userId == request.auth.uid
        && request.resource.data.keys().hasAll(['userId', 'sessionKey', 'encryptedPrivateKey', 'publicKey', 'keyVersion', 'iv', 'createdAt', 'expiresAt', 'used'])
        && request.resource.data.used == false
        // Validate session key is present and reasonable length (43-44 chars base64)
        && request.resource.data.sessionKey is string
        && request.resource.data.sessionKey.size() >= 40
        && request.resource.data.sessionKey.size() <= 50
        // Validate encrypted private key is present and reasonable length
        && request.resource.data.encryptedPrivateKey is string
        && request.resource.data.encryptedPrivateKey.size() > 100
        && request.resource.data.encryptedPrivateKey.size() < 10000
        // Validate encrypted archived keys if present (optional field)
        && (!request.resource.data.keys().hasAny(['encryptedArchivedKeys']) ||
            (request.resource.data.encryptedArchivedKeys is string &&
             request.resource.data.encryptedArchivedKeys.size() < 50000))
        // Validate public key format
        && request.resource.data.publicKey is string
        && request.resource.data.publicKey.size() > 50
        && request.resource.data.publicKey.size() < 1000
        // Validate key version
        && request.resource.data.keyVersion is int
        && request.resource.data.keyVersion > 0
        // Validate IV is present (base64, should be ~24 chars for 16 bytes)
        && request.resource.data.iv is string
        && request.resource.data.iv.size() >= 20
        && request.resource.data.iv.size() <= 30
        // Validate timestamps
        && request.resource.data.createdAt is timestamp
        && request.resource.data.expiresAt is timestamp
        // Expiry must be in future but not too far (max 5 minutes)
        && request.resource.data.expiresAt > request.time
        && request.resource.data.expiresAt < request.time + duration.value(5, 'm');

      // CRITICAL: Only allow reading if the user is either:
      // 1. The owner of this linking session, OR
      // 2. The session hasn't been used yet AND isn't expired
      // This prevents anyone from reading someone else's active linking session
      allow read: if isAuthenticated()
        && isValidLinkToken()
        && (resource.data.userId == request.auth.uid ||
            (resource.data.used == false && isLinkNotExpired()));

      // Only authenticated users can mark as used (and only if not expired)
      // Cannot mark your own linking session as used (prevents self-linking)
      allow update: if isAuthenticated()
        && isValidLinkToken()
        && resource.data.used == false
        && request.resource.data.used == true
        && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['used', 'usedAt', 'linkedDeviceId'])
        // Validate usedBy is present and is the current user
        && request.resource.data.linkedDeviceId is string
        && request.resource.data.linkedDeviceId.size() > 10
        // Cannot use your own device linking session (prevents self-attack)
        && resource.data.userId != request.auth.uid
        // Session must not be expired
        && isLinkNotExpired();

      // Owner can delete their own linking sessions (cancel link)
      allow delete: if isAuthenticated()
        && resource.data.userId == request.auth.uid;
    }

    // 2FA Secrets collection - NEVER readable by clients
    // Only Cloud Functions can access via Admin SDK
    match /2fa_secrets/{userId} {
      allow read, write: if false;
    }

    // 2FA Rate Limiting collection - Read-only for users
    // Only Cloud Functions can write via Admin SDK
    match /2fa_rate_limits/{userId} {
      // Users can read their own rate limit status
      allow read: if isOwner(userId);

      // Only Cloud Functions can write (via Admin SDK)
      allow write: if false;
    }

    // IP Rate Limiting collection - Server-only
    // Tracks 2FA attempts per IP address
    match /ip_rate_limits/{ip} {
      allow read, write: if false;  // Only Cloud Functions via Admin SDK
    }

    // Security logs collection - Write-only, admin read only
    // Cloud Functions write via Admin SDK
    match /security_logs/{logId} {
      // No client reads - logs are for admin/security review only
      allow read: if false;

      // Only Cloud Functions can write (via Admin SDK)
      allow write: if false;
    }

    // Security alerts collection - Admin-only
    // Anomaly detection and suspicious activity alerts
    match /security_alerts/{alertId} {
      allow read, write: if false;  // Only Cloud Functions via Admin SDK
    }

    // Deny all other collections by default
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
