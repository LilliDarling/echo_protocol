import 'dart:typed_data';
import 'package:flutter_test/flutter_test.dart';
import 'package:echo_protocol/utils/security.dart';

void main() {
  group('SecurityUtils secure random generation', () {
    test('generateSecureRandomBytes returns correct length', () {
      final bytes16 = SecurityUtils.generateSecureRandomBytes(16);
      final bytes32 = SecurityUtils.generateSecureRandomBytes(32);
      final bytes64 = SecurityUtils.generateSecureRandomBytes(64);

      expect(bytes16.length, equals(16));
      expect(bytes32.length, equals(32));
      expect(bytes64.length, equals(64));
    });

    test('generateSecureRandomBytes returns Uint8List', () {
      final bytes = SecurityUtils.generateSecureRandomBytes(32);
      expect(bytes, isA<Uint8List>());
    });

    test('generateSecureRandomBytes produces different values each call', () {
      final bytes1 = SecurityUtils.generateSecureRandomBytes(32);
      final bytes2 = SecurityUtils.generateSecureRandomBytes(32);
      final bytes3 = SecurityUtils.generateSecureRandomBytes(32);

      // Extremely unlikely for random bytes to be equal
      expect(bytes1, isNot(equals(bytes2)));
      expect(bytes2, isNot(equals(bytes3)));
      expect(bytes1, isNot(equals(bytes3)));
    });

    test('getSecureRandom returns working SecureRandom instance', () {
      final random = SecurityUtils.getSecureRandom();

      // Should be able to generate bytes
      final bytes = random.nextBytes(32);
      expect(bytes.length, equals(32));

      // Should produce different values
      final bytes2 = random.nextBytes(32);
      expect(bytes, isNot(equals(bytes2)));
    });

    test('generateSecureRandomBytes handles small sizes', () {
      final bytes1 = SecurityUtils.generateSecureRandomBytes(1);
      final bytes4 = SecurityUtils.generateSecureRandomBytes(4);

      expect(bytes1.length, equals(1));
      expect(bytes4.length, equals(4));
    });

    test('generateSecureRandomBytes handles large sizes', () {
      final bytes1024 = SecurityUtils.generateSecureRandomBytes(1024);
      expect(bytes1024.length, equals(1024));
    });

    test('generated bytes have reasonable entropy (not all zeros or ones)', () {
      final bytes = SecurityUtils.generateSecureRandomBytes(256);

      // Count unique byte values
      final uniqueValues = bytes.toSet();

      // With 256 random bytes, we should have many unique values
      // (statistically extremely unlikely to have few unique values)
      expect(uniqueValues.length, greaterThan(50));
    });

    test('multiple SecureRandom instances produce different sequences', () {
      final random1 = SecurityUtils.getSecureRandom();
      final random2 = SecurityUtils.getSecureRandom();

      final bytes1 = random1.nextBytes(32);
      final bytes2 = random2.nextBytes(32);

      // Different instances should produce different sequences
      expect(bytes1, isNot(equals(bytes2)));
    });
  });

  group('SecurityUtils random bytes for cryptographic use', () {
    test('IV generation (12 bytes for GCM)', () {
      final iv = SecurityUtils.generateSecureRandomBytes(12);
      expect(iv.length, equals(12));

      // Verify uniqueness for multiple IVs
      final ivs = List.generate(100, (_) => SecurityUtils.generateSecureRandomBytes(12));
      final uniqueIvs = ivs.map((iv) => iv.toString()).toSet();
      expect(uniqueIvs.length, equals(100));
    });

    test('Key generation (32 bytes for AES-256)', () {
      final key = SecurityUtils.generateSecureRandomBytes(32);
      expect(key.length, equals(32));

      // Verify uniqueness for multiple keys
      final keys = List.generate(100, (_) => SecurityUtils.generateSecureRandomBytes(32));
      final uniqueKeys = keys.map((k) => k.toString()).toSet();
      expect(uniqueKeys.length, equals(100));
    });

    test('Nonce generation (16 bytes)', () {
      final nonce = SecurityUtils.generateSecureRandomBytes(16);
      expect(nonce.length, equals(16));
    });
  });
}
